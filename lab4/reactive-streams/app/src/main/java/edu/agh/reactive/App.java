/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package edu.agh.reactive;
import akka.Done;
import akka.NotUsed;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.japi.Pair;
import akka.stream.*;
import akka.stream.javadsl.*;
import edu.agh.reactive.greetings.GreeterMain;
import edu.agh.reactive.hello.HelloActor;
import edu.agh.reactive.math.MathActor;


import java.io.IOException;
import java.time.Duration;
import java.util.List;
import java.util.concurrent.CompletionStage;

public class App {
    public static void main(String[] args) {
        //////////////////////////////
//        //TASK 0- uncomment code lines + also in try-catch section (grretings)
//        //#actor-system
//        final ActorSystem<GreeterMain.SayHello> greeterMain = ActorSystem.create(GreeterMain.create(), "akka-lab");
//        //#actor-system
//
//        //#main-send-messages
//        greeterMain.tell(new GreeterMain.SayHello("Some-test"));
//        //#main-send-messages

//        //TASK 1 - hello
//        //create actor system
//
//        final ActorSystem<String> helloSystem = ActorSystem.create(HelloActor.create(), "helloActor");
//
//        //send messages
//        helloSystem.tell("hello world");


//        //TASK 2 - math operations
//        final ActorSystem<MathActor.MathCommand> mathContext = ActorSystem.create(MathActor.create(), "actorMath");
//        System.out.println("math main: actor system ready");
//
//      //send messages
//        mathContext.tell(new MathActor.MathCommandAdd(5, 3));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 0, null));
//        try {
//            Thread.sleep(2000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
//
//        System.out.println("Math main: sending second package of messages");
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 3, null));
//        mathContext.tell(new MathActor.MathCommandMultiply(5, 2, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 3, null));
//        mathContext.tell(new MathActor.MathCommandDivide(15, 5, null));
//        System.out.println("Math main: messages send");



//        // TASK 3 - Streams ilustration
//        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
//        final Materializer materializer = Materializer.createMaterializer(streamSystem);
//        // case 1
//        final Source<Integer, NotUsed> source = Source.range(1, 100);
//        final Flow<Integer, String, NotUsed> flow = Flow.fromFunction((Integer n) -> n.toString());
//        final Sink<String, CompletionStage<Done>> sink = Sink.foreach(str->System.out.println(str));
//        final RunnableGraph<NotUsed> runnableGraph = source.via(flow).to(sink);
//        runnableGraph.run(materializer);

        // case 2
//        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
//        final Materializer materializer = Materializer.createMaterializer(streamSystem);
//
//        final Source<Integer, NotUsed> source = Source.range(1, 100);
//        final Flow<Integer, String, NotUsed> debuggingFlow = Flow.fromFunction(n -> {
//            System.out.println("[flow] " + n.toString());
//            return n.toString();
//        });
//        final Sink<String, CompletionStage<Done>> slowSink = Sink.foreach(str -> {
//            Thread.sleep(1000);
//            System.out.println(str);
//        });
//        final RunnableGraph<NotUsed> runnableGraph = source
//                .via(debuggingFlow)
////                .buffer(4, OverflowStrategy.backpressure())
//                .buffer(4, OverflowStrategy.dropTail())
////                .buffer(4, OverflowStrategy.dropHead())
////                .buffer(4, OverflowStrategy.fail())
//                .async()
//                .to(slowSink);
//        runnableGraph.run(materializer);

        //task 4 - graph dsl
        //how to create
        //step 1 - frame
//        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
//        final Materializer materializer = Materializer.createMaterializer(streamSystem);
//        final Source<Integer, NotUsed> source = Source.range(1, 100);
//        final Flow<Integer, Integer, NotUsed> flow = Flow.fromFunction((Integer n) -> n * 10);
//        final Sink<Integer, CompletionStage<Done>> sink = Sink.foreach(str->System.out.println(str));
//        final Graph<ClosedShape, CompletionStage<Done>> specialGraph = GraphDSL.create(sink , (builder, out)-> {
//            //step 2 - building blocks
//                builder.add(sink);
//            final Outlet<Integer> dslSource = builder.add(source).out();
//            //step 3 - glue components
//                builder.from(dslSource).via(builder.add(flow)).to(out);
//            //step 4 closing
//                return ClosedShape.getInstance();
//                });
//
//        RunnableGraph.fromGraph(specialGraph).run(materializer);

        final ActorSystem streamSystem = ActorSystem.create(Behaviors.empty(), "streams");
        final Materializer materializer = Materializer.createMaterializer(streamSystem);
        final Source<Integer, NotUsed> source = Source.range(1, 100);
        final Flow<Integer, Integer, NotUsed> flow1 = Flow.fromFunction((Integer n) -> n + 1);
        final Flow<Integer, Integer, NotUsed> flow2 = Flow.fromFunction((Integer n) -> n * 10);
        final Flow<Pair<Integer, Integer>, String, NotUsed> flow3 = Flow.fromFunction(Pair::toString);
        final Sink<String, CompletionStage<Done>> sink = Sink.foreach(System.out::println);
        final Graph<ClosedShape, CompletionStage<Done>> specialGraph = GraphDSL.create(sink , (builder, out)-> {

            final Outlet<Integer> dslSource = builder.add(source).out();
            final  UniformFanOutShape<Integer, Integer> broadcast = builder.add(Broadcast.create(2));
            final  FanInShape2<Integer, Integer, Pair<Integer, Integer>> zip = builder.add(Zip.create());

            builder.from(dslSource).viaFanOut(broadcast).via(builder.add(flow1)).toInlet(zip.in0());
            builder.from(broadcast).via(builder.add(flow2)).toInlet(zip.in1());
            builder.from(zip.out()).via(builder.add(flow3)).to(out);

            return ClosedShape.getInstance();
        });

        RunnableGraph.fromGraph(specialGraph).run(materializer);

        try {
            System.out.println(">>> Press ENTER to exit <<<");
            System.in.read();
        } catch (IOException ignored) {
        } finally {
//            greeterMain.terminate();
//            mathContext.terminate();
//            helloSystem.terminate();
//            streamSystem.terminate();
        }
    }
}
